# Теория многопоточности

* [Введение в многопоточность](#%D0%B2%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C)
* [Терминология: многопоточность, конкурентность, параллельность](#%D1%82%D0%B5%D1%80%D0%BC%D0%B8%D0%BD%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D1%8F-%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C-%D0%BA%D0%BE%D0%BD%D0%BA%D1%83%D1%80%D0%B5%D0%BD%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C-%D0%BF%D0%B0%D1%80%D0%B0%D0%BB%D0%BB%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D1%8C)
* [Задача масштабирования](#%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-%D0%BC%D0%B0%D1%81%D1%88%D1%82%D0%B0%D0%B1%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)
    * [Закон Амдала](#%D0%B7%D0%B0%D0%BA%D0%BE%D0%BD-%D0%B0%D0%BC%D0%B4%D0%B0%D0%BB%D0%B0)
    * [Универсальный закон Масштабирования или модель Гюнтера (USL)](#%D1%83%D0%BD%D0%B8%D0%B2%D0%B5%D1%80%D1%81%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9-%D0%B7%D0%B0%D0%BA%D0%BE%D0%BD-%D0%BC%D0%B0%D1%81%D1%88%D1%82%D0%B0%D0%B1%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B8%D0%BB%D0%B8-%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C-%D0%B3%D1%8E%D0%BD%D1%82%D0%B5%D1%80%D0%B0-usl)
* [Потоки в Java](#%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B8-%D0%B2-java)
    * [Жизненный цикл потока и состояния](#%D0%B6%D0%B8%D0%B7%D0%BD%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9-%D1%86%D0%B8%D0%BA%D0%BB-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B0-%D0%BF%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD-%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F%D0%BC%D0%B8)
    * [Thread API](#thread-api)
    * [Завершение работы потока](#%D0%B7%D0%B0%D0%B2%D0%B5%D1%80%D1%88%D0%B5%D0%BD%D0%B8%D0%B5-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%8B-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B0)
    * [Монитор](#%D0%BC%D0%BE%D0%BD%D0%B8%D1%82%D0%BE%D1%80)
* Потокобезопасность: проблемы многопоточности

# Практика многопоточности

* Синхронизация потоков и координация доступа к разделяемым ресурсам
* Атомарные переменные
* Потокобезопасные коллекции
* Пример многопоточной программы
* Выявление ошибок с помощью инструментов jstack, dlcheck и пр.
* Правила и рекомендации для потокобезопасного кода


## Введение в многопоточность

### Выгоды

При использовании нескольких потоков можно проектировать приложение таким образом, чтобы оно могло решать одновременно несколько задач в рамках одного процесса, при этом каждый поток занят решение отдельной задачи. Это дает преимущества:
* Упрощение - поток выполняет предназначенную только для него логику и порцию работы общей задачи.
* Крупные задачи можно разбить на подзадачи, которые будут решаться в отдельных потоках, что даст увеличение производительности за счет использования вычислительных ядер работающих параллельно.
* Повышение отзывчивости приложений управляемых интерактивно за счет предоставления управлению отдельного потока.


## Терминология: многопоточность, конкурентность, параллельность

__Многопоточность__ - свойство исполняющей среды (JVM) дающее возможность исполнять несколько потоков, таким образом что можно выполнять задачи или части задач в промежутках времени которые могут пересекаться, а могут и не пересекаться. 

__Concurrency (Одновременность или Конкурентность)__ - свойство программы выполнять более одной задачи одновременно. Одновременно это не значит что у вас есть 2 единицы работы и они выполяются в один и тот же момент времени. Это означает что даже на 1 процессоре с 1 ядром может быть множество потоков, которые выполняют свои программы в отведенный им квант времени.

__Параллелизм__ - две или более задачи исполняются параллельно то есть буквально в один и тот же момент времени, либо на одной многоядерной машине, либо в распределенной среде.


## Задача масштабирования

Когда мы имеем дело с выполнением задач в многопоточной среде, у нас возникает вопрос о том, как посчитать насколько быстрее наша программа может выполняться в сравнении с однопоточным исполнением.

### Закон Амдала

Мы можем разбить алгоритм при условии, что набор данных для какой-то части программы может быть вычислен независимо. Если алгоритм может быть разбит на множество независимых блоков, то мы имеем прирост производительности пропорционально количеству параллельных блоков. Но какая-то часть вычислений не может быть выполнена независимо, то есть всегда есть некоторая последовательная часть вычислений. Предел эффективности распараллеливания ограничен сверху некоторым значением. На графике можно увидеть, что с увеличением кол-ва процессоров (или ядер) алгоритм имеет некий предел, при достижении которого преимуществ от использования дополнительных ядер уже не будет.

![Amdahl's Law](images/amdahls-law.png)

При этом тут не учитываются некоторые эффекты присутствующие в реальных системах. Есть накладные расходы связанные с иерархией кэшей в современных системах. Результаты вычислений производимых ядром первоначально могут сохраняться только в определенных уровнях кэшей, но в конечном итоге результаты вычислений должны быть отражены в общей памяти.

Помимо аппаратных издержек есть еще общие ресурсы (общие структуры данных, сетевые подключения, базы данных) разделяемые между множеством потоков. Работа с общими ресурсами вносит существенный вклад в работу многопоточного приложения. Об этом говорит логичное продолжение закона Амдала - Универсальный закон Масштабирования.

### Универсальный закон Масштабирования или модель Гюнтера (USL)

При использовании параллелизма необходимо учитывать накладные расходы, которые возникают при увеличении степени параллелизма:
* из-за обмена общими перезаписываемыми данными между кэшами процессора и между процессорами и основной памятью
* блокировки синхронизации общих данных для обеспечения экслюзивного доступа к ресурсам
* ожидание доступа к памяти
* и т.п.

Следствием обобщения закона Амдала, является универсальная модель Гюнтера, не учитывающая каких-либо свойств алгоритма, ПО или конкретной архитектуры многоядерной системы.

Согласно этой модели, ускорение имеет глобальный максимум с увеличением кол-ва ядер (процессоров) из-за дополнительных издержек, например поддержания согласованности данных между ядрами.


## Потоки в Java

Java предоставляет класс Thread и среда исполнения позволяет запускать множество потоков одновременно.

Есть разные модели потоков: 
* модель "один к одному", когда один поток JVM соответствует одному потоку операционной системы - это реализация HotSpot
* модель "один ко многим", когда есть 1 поток операционной системы и множество легковесных потоков - это реализация Project Loom

Потоки делятся на два типа: 
* Обычные - JVM не завершает работу пока все обычные потоки еще работают.
* Демоны, то есть фоновые потоки - JVM не дожидается завершения работы потоков демонов.
* JVM сначала запускает хуки - не запущенные потоки. Хуки регистрируются с помощью метода Runtime.addShutdownHook. Запуск хуков не упорядочен. Работа хуков задерживает прерывание JVM. Хуки могут быть использованы для корректного освобождения ресурсов и завершения работы потока (демона).
* При запуске JVM все потоки являются демонами, кроме главного потока исполнения Main.
* Новый поток наследует тип создавшего его потока.
* Порядок запуска потоков недетерминирован.
* У потока есть стек и жизненный цикл.

### Жизненный цикл потока представлен состояниями

* NEW - поток создан, но еще не запущен.
* RUNNABLE - после вызова метода start().
* BLOCKED - поток заблокирован до того момента как он может захватить монитор чтобы войти в synchronized секцию или метод.
* WAITING - поток ожидает пока другой поток не выполнит определенное действие
* TIMED_WAITING - ожидание с таймаутом
* TERMINATED - работа потока завершена, после этого его уже нельзя перезапустить.

![Thread States](images/thread-states.png)

### У потока есть

* Идентификатор
* Имя
* Приоритет
* Флаг - прерван ли поток
* Флаг - является ли поток демоном
* Статус потока

### Thread API

* join() - текущий поток будет ожидать, пока целевой поток не завершится, переводит в состояние WAITING или TIMED_WAITING
* interrupt() - устанавливает для потока статус 'interrupt'
* isInterrupted()
* isDaemon()
* start() - запускает работу в новом потоке
* stop() - давно deprecated, так как важно корректно завершить поток
* getStackTrace() - для получения отладочной информации

[Пример: состояния и метод join()](src/main/java/learn/jconcurrency/lifecycle/JoinThreadExample.java)

[Пример: вызов run() вместо start() не приводит к старту потока](src/main/java/learn/jconcurrency/lifecycle/NotRunningExample.java)

Для получения ID Java процесса: `jps -l`  
Для получения информации о потоках процесса: `jstack`


### Завершение работы потока

Для корректной остановки потока необходимо логически задать условие для завершения метода `run()`.
Для этого можно установить флаг 'interrupt' с помощью вызова метода `interrupt()`, а для проверки
статуса использовать метод `isInterrupted()`.  
Если целевой поток находился в состоянии WAITING или TIMED_WAITING в момент вызова метода interrupt(),
то будет выброшено `java.lang.InterruptedException`.  
Чтобы этого избежать можно в цикле потока периодически проверять условие `Thread.currentThread().isInterrupted()`.

[Пример: вызов interrupt() и завершение потока](src/main/java/learn/jconcurrency/lifecycle/InterruptedThreadExample.java)


### Монитор

Когда мы говорим о мониторе, то подразумеваем следующее. У любого объекта в Java есть представление в JVM,
есть низкоуровневый (с точки зрения виртуальной машины) объект, о котором мы не знаем, и у этого объекта
есть заголовки содержащие системно значимую информацию. В этих заголовках могут храниться различные аттрибуты:
сколько сборок мусора пережил объект, какой поток его ожидает, или иметь ссылку на монитор.  
В JVM есть классы ObjectMonitor и ObjectWaiter, с помощью которых реализован механизм позволяющий нам захватывать 
монитор и ожидать некоторого события. Когда мы вызываем методы `wait()` или `notify()`/`notifyAll()` в совокупности с 
ключевым словом `synchronized`, то мы говорим следующее: объект, перед тем как вызвать метод wait() захвати 
монитор вот на таком объекте. Важной характеристикой монитора объекта является то что по сути это является
эксклюзивной блокировкой - когда мы захватываем монитор в одном потоке, то до тех пор пока мы не выйдем из
synchronized секции, монитор не будет освобожден, а значит любой другой поток, который попытается этот монитор
захватить, будет блокирован.  
Но когда мы вызываем методы `wait()`, то мы позволяем другому потоку захватить этот же монитор, для того чтобы
пробудить тот поток, который ожидает на этом же мониторе какого-то события.

#### Схема ObjectMonitor

![ObjectMonitor](images/object-monitor.png)

В виртуальной машине HotSpot монитор реализуется ObjectMonitor.  
Каждый поток имеет два списка объектов ObjectMonitor, которые являются свободными и используемыми списками. 
Если текущий свободный список пуст, поток запросит выделение ObjectMonitor из глобального списка.

В объекте ObjectMonitor есть две очереди: WaitSet и EntryList, которые используются для хранения списка 
объектов ObjectWaiter; owner указывает на поток, который получает объект ObjectMonitor.

WaitSet: потоки в состоянии ожидания будут добавлены в набор ожидания.  
EntryList: потоки в состоянии ожидания блока блокировки будут добавлены к набору записей.

ObjectWaiter представляет собой структуру двусвязного списка, в которой сохраняются такие данные, как _thread 
(текущий поток) и текущее состояние TState. Каждый поток, ожидающий блокировки, будет инкапсулирован в объект ObjectWaiter.

[Пример: wait() на мониторе](src/main/java/learn/jconcurrency/lifecycle/WaitingThreadExample.java)

[Пример: terminated thread](src/main/java/learn/jconcurrency/lifecycle/TerminatedThreadExample.java)

## Потокобезопасность: проблемы многопоточности



