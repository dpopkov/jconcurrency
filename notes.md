# Теория многопоточности

* Введение в многопоточность
* Терминология: многопоточность, конкурентность, параллельность
* Задача масштабирования
* Потоки в Java
* Потокобезопасность: проблемы многопоточности

# Практика многопоточности

* Синхронизация потоков и координация доступа к разделяемым ресурсам
* Атомарные переменные
* Потокобезопасные коллекции
* Пример многопоточной программы
* Выявление ошибок с помощью инструментов jstack, dlcheck и пр.
* Правила и рекомендации для потокобезопасного кода


## Введение в многопоточность

### Выгоды

При использовании нескольких потоков можно проектировать приложение таким образом, чтобы оно могло решать одновременно несколько задач в рамках одного процесса, при этом каждый поток занят решение отдельной задачи. Это дает преимущества:
* Упрощение - поток выполняет предназначенную только для него логику и порцию работы общей задачи.
* Крупные задачи можно разбить на подзадачи, которые будут решаться в отдельных потоках, что даст увеличение производительности за счет использования вычислительных ядер работающих параллельно.
* Повышение отзывчивости приложений управляемых интерактивно за счет предоставления управлению отдельного потока.


## Терминология: многопоточность, конкурентность, параллельность

__Многопоточность__ - свойство исполняющей среды (JVM) дающее возможность исполнять несколько потоков, таким образом что можно выполнять задачи или части задач в промежутках времени которые могут пересекаться, а могут и не пересекаться. 

__Concurrency (Одновременность или Конкурентность)__ - свойство программы выполнять более одной задачи одновременно. Одновременно это не значит что у вас есть 2 единицы работы и они выполяются в один и тот же момент времени. Это означает что даже на 1 процессоре с 1 ядром может быть множество потоков, которые выполняют свои программы в отведенный им квант времени.

__Параллелизм__ - две или более задачи исполняются параллельно то есть буквально в один и тот же момент времени, либо на одной многоядерной машине, либо в распределенной среде.


## Задача масштабирования

Когда мы имеем дело с выполнением задач в многопоточной среде, у нас возникает вопрос о том, как посчитать насколько быстрее наша программа может выполняться в сравнении с однопоточным исполнением.

Линейное масштабирование

### Закон Амдала

Мы можем разбить алгоритм при условии, что набор данных для какой-то части программы может быть вычислен независимо. Если алгоритм может быть разбит на множество независимых блоков, то мы имеем прирост производительности пропорционально количеству параллельных блоков. Но какая-то часть вычислений не может быть выполнена независимо, то есть всегда есть некоторая последовательная часть вычислений. Предел эффективности распараллеливания ограничен сверху некоторым значением. На графике можно увидеть, что с увеличением кол-ва процессоров (или ядер) алгоритм имеет некий предел, при достижении которого преимуществ от использования дополнительных ядер уже не будет.

![Amdahl's Law](images/amdahls-law.png)

При этом тут не учитываются некоторые эффекты присутствующие в реальных системах. Есть накладные расходы связанные с иерархией кэшей в современных системах. Результаты вычислений производимых ядром первоначально могут сохраняться только в определенных уровнях кэшей, но в конечном итоге результаты вычислений должны быть отражены в общей памяти.

Помимо аппаратных издержек есть еще общие ресурсы (общие структуры данных, сетевые подключения, базы данных) разделяемые между множеством потоков. Работа с общими ресурсами вносит существенный вклад в работу многопоточного приложения. Об этом говорит логичное продолжение закона Амдала - Универсальный закон Масштабирования.

### Универсальный закон Масштабирования или модель Гюнтера (USL)

При использовании параллелизма необходимо учитывать накладные расходы, которые возникают при увеличении степени параллелизма:
* из-за обмена общими перезаписываемыми данными между кэшами процессора и между процессорами и основной памятью
* блокировки синхронизации общих данных для обеспечения экслюзивного доступа к ресурсам
* ожидание доступа к памяти
* и т.п.

Следствием обобщения закона Амдала, является универсальная модель Гюнтера, не учитывающая каких-либо свойств алгоритма, ПО или конкретной архитектуры многоядерной системы.

Согласно этой модели, ускорение имеет глобальный максимум с увеличением кол-ва ядер (процессоров) из-за дополнительных издержек, например поддержания согласованности данных между ядрами.


## Потоки в Java

Java предоставляет класс Thread и среда исполнения позволяет запускать множество потоков одновременно.

Есть разные модели потоков: 
* модель "один к одному", когда один поток JVM соответствует одному потоку операционной системы - это реализация HotSpot
* модель "один ко многим", когда есть 1 поток операционной системы и множество легковесных потоков - это реализация Project Loom

Потоки делятся на два типа: 
* Обычные - JVM не завершает работу пока все обычные потоки еще работают.
* Демоны, то есть фоновые потоки - JVM не дожидается завершения работы потоков демонов.
* JVM сначала запускает хуки - не запущенные потоки. Хуки регистрируются с помощью метода Runtime.addShutdownHook. Запуск хуков не упорядочен. Работа хуков задерживает прерывание JVM. Хуки могут быть использованы для корректного освобождения ресурсов и завершения работы потока (демона).
* При запуске JVM все потоки являются демонами, кроме главного потока исполнения Main.
* Новый поток наследует тип создавшего его потока.
* Порядок запуска потоков недетерминирован.
* У потока есть стек и жизненный цикл.

### Жизненный цикл потока представлен состояниями

* NEW - поток создан, но еще не запущен.
* RUNNABLE - после вызова метода start().
* BLOCKED - поток заблокирован до того момента как он может захватить монитор чтобы войти в synchronized секцию или метод.
* WAITING - поток ожидает пока другой поток не выполнит определенное действие
* TIMED_WAITING - ожидание с таймаутом
* TERMINATED - работа потока завершена, после этого его уже нельзя перезапустить.

![Thread States](images/thread-states.png)

### Thread API

* join() - текущий поток будет ожидать, пока целевой поток не завершится, переводит в TIMED_WAITING
* interrupt()
* isInterrupted()
* isDaemon()
* start()
* stop() - давно deprecated, так как важно корректно завершить поток
* getStackTrace()

[Пример: состояния и метод join()](src/main/java/learn/jconcurrency/lifecycle/JoinThreadExample.java)


## Потокобезопасность: проблемы многопоточности



